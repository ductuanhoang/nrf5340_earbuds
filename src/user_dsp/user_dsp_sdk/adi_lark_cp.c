/*!
 * @brief     Control Port APIs Implementation
 * @copyright Copyright (c) 2020 - Analog Devices Inc. All Rights Reserved.
 */

/*!
 * @addtogroup adi_lark_sdk
 * @{
 */

/*============= I N C L U D E S ============*/
#include "adi_lark.h"

/*============= D E F I N E S ==============*/
#define LARK_CP_ADDR_BYTE3(x)           (((x) >> 24) & 0xFF)
#define LARK_CP_ADDR_BYTE2(x)           (((x) >> 16) & 0xFF)
#define LARK_CP_ADDR_BYTE1(x)           (((x) >> 8)  & 0xFF)
#define LARK_CP_ADDR_BYTE0(x)           (((x)     )  & 0xFF)

#define LARK_CP_SPI_CMD_WR              (0x00)
#define LARK_CP_SPI_CMD_RD              (0x01)
#define LARK_CP_SPI_DUMMY               (0x00)
#ifdef  LARK_LITE_SDK
#define LARK_CP_SPI_RD_HEAD             (4)
#define LARK_CP_SPI_WR_HEAD             (4)
#endif
#ifdef  LARK_SDK
#define LARK_CP_SPI_RD_HEAD             (6)
#define LARK_CP_SPI_WR_HEAD             (6)
#endif

#ifdef  LARK_LITE_SDK
#define LARK_CP_I2C_RD_HEAD             (2)
#define LARK_CP_I2C_WR_HEAD             (2)
#endif
#ifdef  LARK_SDK
#define LARK_CP_I2C_RD_HEAD             (4)
#define LARK_CP_I2C_WR_HEAD             (4)
#endif

#define LARK_CP_UART_ID                 (0x00)
#define LARK_CP_UART_CMD_WR             (0x00)
#define LARK_CP_UART_CMD_RD             (0x80)
#define LARK_CP_UART_FRAME_HEAD         (0x01)
#define LARK_CP_UART_FRAME_TAIL         (0xF0)
#define LARK_CP_UART_ESCAPE             (0xFF)
#define LARK_CP_UART_ESCAPE_MASK        (0x20)
#define LARK_CP_UART_CRC_INIT           (0xFF)
#define LARK_CP_UART_HEAD_MIN_OVERHEAD  (11)

typedef struct
{
    uint8_t  index;
    uint8_t  crc_out;
    uint8_t  fill_type;
    uint32_t reg_addr;
    uint8_t  *reg_data;
} adi_lark_cp_uart_reg_t;

typedef enum
{
    LARK_CP_UART_WRITE_STAT_STATE_HEAD      = 0,
    LARK_CP_UART_WRITE_STAT_STATE_ID        = 1,
    LARK_CP_UART_WRITE_STAT_STATE_STAT      = 2,
    LARK_CP_UART_WRITE_STAT_STATE_CRC       = 3,
    LARK_CP_UART_WRITE_STAT_STATE_TAIL      = 4,
    LARK_CP_UART_WRITE_STAT_STATE_FINISHED  = 5,
} adi_lark_cp_uart_write_stat_state_e;

typedef enum
{
    LARK_CP_UART_READ_DATA_STATE_HEAD       = 0,
    LARK_CP_UART_READ_DATA_STATE_ID         = 1,
    LARK_CP_UART_READ_DATA_STATE_STAT       = 2,
    LARK_CP_UART_READ_DATA_STATE_DATA       = 3,
    LARK_CP_UART_READ_DATA_STATE_CRC        = 4,
    LARK_CP_UART_READ_DATA_STATE_TAIL       = 5,
    LARK_CP_UART_READ_DATA_STATE_FINISHED   = 6,
} adi_lark_cp_uart_read_data_state_e;

typedef enum
{
    LARK_CP_UART_READ_TYPE_REG              = 0,
    LARK_CP_UART_READ_TYPE_MEM              = 1
} adi_lark_cp_uart_read_type_e;

typedef enum
{
    LARK_CP_UART_FILL_TYPE_4_BYTE           = 0,
    LARK_CP_UART_FILL_TYPE_1_BYTE           = 1
} adi_lark_cp_uart_fill_type_e;

/*=================== D A T A ====================*/
/*!
 * @brief CRC8 lookup table for uart, generated by crc8_table_create.py, using x^8+x^7+x^3+x^2+1
 */
#if (LARK_SDK_RUN_ON_HIFI3Z == 0)
static uint8_t crc8_table[256] =
{
    0x00, 0x8d, 0x97, 0x1a, 0xa3, 0x2e, 0x34, 0xb9, 0xcb, 0x46, 0x5c, 0xd1, 0x68, 0xe5, 0xff, 0x72,
    0x1b, 0x96, 0x8c, 0x01, 0xb8, 0x35, 0x2f, 0xa2, 0xd0, 0x5d, 0x47, 0xca, 0x73, 0xfe, 0xe4, 0x69,
    0x36, 0xbb, 0xa1, 0x2c, 0x95, 0x18, 0x02, 0x8f, 0xfd, 0x70, 0x6a, 0xe7, 0x5e, 0xd3, 0xc9, 0x44,
    0x2d, 0xa0, 0xba, 0x37, 0x8e, 0x03, 0x19, 0x94, 0xe6, 0x6b, 0x71, 0xfc, 0x45, 0xc8, 0xd2, 0x5f,
    0x6c, 0xe1, 0xfb, 0x76, 0xcf, 0x42, 0x58, 0xd5, 0xa7, 0x2a, 0x30, 0xbd, 0x04, 0x89, 0x93, 0x1e,
    0x77, 0xfa, 0xe0, 0x6d, 0xd4, 0x59, 0x43, 0xce, 0xbc, 0x31, 0x2b, 0xa6, 0x1f, 0x92, 0x88, 0x05,
    0x5a, 0xd7, 0xcd, 0x40, 0xf9, 0x74, 0x6e, 0xe3, 0x91, 0x1c, 0x06, 0x8b, 0x32, 0xbf, 0xa5, 0x28,
    0x41, 0xcc, 0xd6, 0x5b, 0xe2, 0x6f, 0x75, 0xf8, 0x8a, 0x07, 0x1d, 0x90, 0x29, 0xa4, 0xbe, 0x33,
    0xd8, 0x55, 0x4f, 0xc2, 0x7b, 0xf6, 0xec, 0x61, 0x13, 0x9e, 0x84, 0x09, 0xb0, 0x3d, 0x27, 0xaa,
    0xc3, 0x4e, 0x54, 0xd9, 0x60, 0xed, 0xf7, 0x7a, 0x08, 0x85, 0x9f, 0x12, 0xab, 0x26, 0x3c, 0xb1,
    0xee, 0x63, 0x79, 0xf4, 0x4d, 0xc0, 0xda, 0x57, 0x25, 0xa8, 0xb2, 0x3f, 0x86, 0x0b, 0x11, 0x9c,
    0xf5, 0x78, 0x62, 0xef, 0x56, 0xdb, 0xc1, 0x4c, 0x3e, 0xb3, 0xa9, 0x24, 0x9d, 0x10, 0x0a, 0x87,
    0xb4, 0x39, 0x23, 0xae, 0x17, 0x9a, 0x80, 0x0d, 0x7f, 0xf2, 0xe8, 0x65, 0xdc, 0x51, 0x4b, 0xc6,
    0xaf, 0x22, 0x38, 0xb5, 0x0c, 0x81, 0x9b, 0x16, 0x64, 0xe9, 0xf3, 0x7e, 0xc7, 0x4a, 0x50, 0xdd,
    0x82, 0x0f, 0x15, 0x98, 0x21, 0xac, 0xb6, 0x3b, 0x49, 0xc4, 0xde, 0x53, 0xea, 0x67, 0x7d, 0xf0,
    0x99, 0x14, 0x0e, 0x83, 0x3a, 0xb7, 0xad, 0x20, 0x52, 0xdf, 0xc5, 0x48, 0xf1, 0x7c, 0x66, 0xeb
};
#endif

/*!
 * @brief global buffer for control port read/write, valid when running sdk on external cpu
 */
#if (LARK_SDK_RUN_ON_HIFI3Z == 0)
static uint8_t wr_buf[LARK_SDK_MAX_BUFSIZE];
static uint8_t rd_buf[LARK_SDK_MAX_BUFSIZE];
#endif

/*============= C O D E ====================*/
int32_t adi_lark_cp_check_addr_length(uint32_t first_byte_addr, uint32_t length, uint8_t *reg_width);
int32_t adi_lark_cp_uart_fill_buffer(adi_lark_cp_uart_reg_t *uart_reg, uint8_t *buf, uint32_t data_len, uint8_t rw_type);
int32_t adi_lark_cp_uart_fill_data(adi_lark_cp_uart_reg_t *uart_reg, uint8_t *buf, uint32_t data_len, uint8_t *data);
int32_t adi_lark_cp_uart_update_crc8(uint8_t crc_in, uint8_t data_byte, uint8_t *crc_out);
int32_t adi_lark_cp_uart_check_write_stat(adi_lark_device_t *device, uint8_t write_id, uint8_t *stat);
int32_t adi_lark_cp_uart_parse_read_data(adi_lark_device_t *device, uint8_t read_id, uint8_t *reg_data, uint32_t data_len, uint32_t read_type);

int32_t adi_lark_cp_spi_mem_read(adi_lark_device_t *device, uint32_t addr, uint8_t *data, uint32_t byte_length)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t  err, max_payload_size;
    uint32_t i, data_offset, frame_payload_size;
    uint8_t  reg_width;

    LARK_NULL_POINTER_RETURN(device);
    LARK_NULL_POINTER_RETURN(device->read);

    err = adi_lark_cp_check_addr_length(addr, byte_length, &reg_width);
    LARK_ERROR_RETURN(err);

    max_payload_size = LARK_SDK_MAX_BUFSIZE - LARK_CP_SPI_RD_HEAD; /* max payload size, limited by buffer and read head */
    max_payload_size -= max_payload_size % reg_width;              /* if register is 32bit, must access by 4-multiple bytes */
    LARK_INVALID_PARAM_RETURN (max_payload_size < 1);

    for (data_offset = 0; data_offset < byte_length; data_offset += max_payload_size) /* generate frames */
    {
        frame_payload_size = (byte_length - data_offset < max_payload_size) ? byte_length - data_offset : max_payload_size;
        wr_buf[0] = LARK_CP_SPI_CMD_RD;
        #ifdef LARK_LITE_SDK
        wr_buf[1] = LARK_CP_ADDR_BYTE1(data_offset + addr); /* starting address [15:08] */
        wr_buf[2] = LARK_CP_ADDR_BYTE0(data_offset + addr); /* starting address [07:00] */
        wr_buf[3] = LARK_CP_SPI_DUMMY;
        #endif
        #ifdef LARK_SDK
        wr_buf[1] = LARK_CP_ADDR_BYTE3(data_offset + addr); /* starting address [31:24] */
        wr_buf[2] = LARK_CP_ADDR_BYTE2(data_offset + addr); /* starting address [23:16] */
        wr_buf[3] = LARK_CP_ADDR_BYTE1(data_offset + addr); /* starting address [15:08] */
        wr_buf[4] = LARK_CP_ADDR_BYTE0(data_offset + addr); /* starting address [07:00] */
        wr_buf[5] = LARK_CP_SPI_DUMMY;
        #endif
        err = device->read(device->user_data, rd_buf, frame_payload_size, wr_buf, frame_payload_size + LARK_CP_SPI_RD_HEAD);
        LARK_ERROR_RETURN(err);

        for (i = 0; i < frame_payload_size; i += 1) /* returned payload from above are also offset by SPI_RD_HEAD */
        {
            data[data_offset + i] = rd_buf[i + LARK_CP_SPI_RD_HEAD];
        }
    }
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_spi_mem_write(adi_lark_device_t *device, uint32_t addr, uint8_t *data, uint32_t byte_length)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t  err, max_payload_size;
    uint32_t i, data_offset, frame_payload_size;
    uint8_t  reg_width;

    LARK_NULL_POINTER_RETURN(device);
    LARK_NULL_POINTER_RETURN(device->write);

    err = adi_lark_cp_check_addr_length(addr, byte_length, &reg_width);
    LARK_ERROR_RETURN(err);

    max_payload_size = LARK_SDK_MAX_BUFSIZE - LARK_CP_SPI_WR_HEAD; /* max payload size, limited by buffer and read head */
    max_payload_size -= max_payload_size % reg_width;              /* if register is 32bit, must access by 4-multiple bytes*/
    LARK_INVALID_PARAM_RETURN (max_payload_size < 1);

    for (data_offset = 0; data_offset < byte_length; data_offset += max_payload_size) /* generate frames */
    {
        frame_payload_size = (byte_length - data_offset < max_payload_size) ? byte_length - data_offset : max_payload_size;
        wr_buf[0] = LARK_CP_SPI_CMD_WR;
        #ifdef LARK_LITE_SDK
        wr_buf[1] = LARK_CP_ADDR_BYTE1(data_offset + addr); /* starting address [15:08] */
        wr_buf[2] = LARK_CP_ADDR_BYTE0(data_offset + addr); /* starting address [07:00] */
        wr_buf[3] = LARK_CP_SPI_DUMMY;
        #endif
        #ifdef LARK_SDK
        wr_buf[1] = LARK_CP_ADDR_BYTE3(data_offset + addr); /* starting address [31:24] */
        wr_buf[2] = LARK_CP_ADDR_BYTE2(data_offset + addr); /* starting address [23:16] */
        wr_buf[3] = LARK_CP_ADDR_BYTE1(data_offset + addr); /* starting address [15:08] */
        wr_buf[4] = LARK_CP_ADDR_BYTE0(data_offset + addr); /* starting address [07:00] */
        wr_buf[5] = LARK_CP_SPI_DUMMY;
        #endif
        for (i = 0; i < frame_payload_size; i += 1) /* payload placed after WR head */
        {
            wr_buf[LARK_CP_SPI_WR_HEAD + i] = data[data_offset + i];
        }

        err = device->write(device->user_data, wr_buf, frame_payload_size + LARK_CP_SPI_WR_HEAD);
        LARK_ERROR_RETURN(err);
    }
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_spi_reg_read(adi_lark_device_t *device, uint32_t reg_addr, uint32_t *reg_data)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t  err, max_payload_size;
    uint32_t i;
    uint8_t  reg_width;

    LARK_NULL_POINTER_RETURN(device);
    LARK_NULL_POINTER_RETURN(device->read);

    err = adi_lark_cp_check_addr_length(reg_addr, 0, &reg_width);
    LARK_ERROR_RETURN(err);

    max_payload_size = LARK_SDK_MAX_BUFSIZE - LARK_CP_SPI_WR_HEAD; /* max payload size, limited by buffer and read head */
    max_payload_size -= max_payload_size % reg_width;              /* if register is 32bit, must access by 4-multiple bytes*/
    LARK_INVALID_PARAM_RETURN (max_payload_size < 1);

    wr_buf[0] = LARK_CP_SPI_CMD_RD;
    #ifdef LARK_LITE_SDK
    wr_buf[1] = LARK_CP_ADDR_BYTE1(reg_addr); /* starting address [15:08] */
    wr_buf[2] = LARK_CP_ADDR_BYTE0(reg_addr); /* starting address [07:00] */
    wr_buf[3] = LARK_CP_SPI_DUMMY;
    #endif
    #ifdef LARK_SDK
    wr_buf[1] = LARK_CP_ADDR_BYTE3(reg_addr); /* starting address [31:24] */
    wr_buf[2] = LARK_CP_ADDR_BYTE2(reg_addr); /* starting address [23:16] */
    wr_buf[3] = LARK_CP_ADDR_BYTE1(reg_addr); /* starting address [15:08] */
    wr_buf[4] = LARK_CP_ADDR_BYTE0(reg_addr); /* starting address [07:00] */
    wr_buf[5] = LARK_CP_SPI_DUMMY;
    #endif

    err = device->read(device->user_data, rd_buf, reg_width, wr_buf, reg_width + LARK_CP_SPI_RD_HEAD);
    LARK_ERROR_RETURN(err);

    *reg_data = 0;
    for (i = 0; i < reg_width; i += 1) /* returned payload from above are also offset by SPI_RD_HEAD */
    {
        *reg_data += rd_buf[i + LARK_CP_SPI_RD_HEAD] << (i * 8);
    }
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_spi_reg_write(adi_lark_device_t *device, uint32_t reg_addr, uint32_t reg_data)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t  err, max_payload_size;
    uint32_t i;
    uint8_t  reg_width;

    LARK_NULL_POINTER_RETURN(device);
    LARK_NULL_POINTER_RETURN(device->write);

    err = adi_lark_cp_check_addr_length(reg_addr, 0, &reg_width);
    LARK_ERROR_RETURN(err);

    max_payload_size = LARK_SDK_MAX_BUFSIZE - LARK_CP_SPI_WR_HEAD; /* max payload size, limited by buffer and read head */
    max_payload_size -= max_payload_size % reg_width;              /* if register is 32bit, must access by 4-multiple bytes*/
    LARK_INVALID_PARAM_RETURN (max_payload_size < 1);

    wr_buf[0] = LARK_CP_SPI_CMD_WR;
    #ifdef LARK_LITE_SDK
    wr_buf[1] = LARK_CP_ADDR_BYTE1(reg_addr); /* starting address [15:08] */
    wr_buf[2] = LARK_CP_ADDR_BYTE0(reg_addr); /* starting address [07:00] */
    wr_buf[3] = LARK_CP_SPI_DUMMY;
    #endif
    #ifdef LARK_SDK
    wr_buf[1] = LARK_CP_ADDR_BYTE3(reg_addr); /* starting address [31:24] */
    wr_buf[2] = LARK_CP_ADDR_BYTE2(reg_addr); /* starting address [23:16] */
    wr_buf[3] = LARK_CP_ADDR_BYTE1(reg_addr); /* starting address [15:08] */
    wr_buf[4] = LARK_CP_ADDR_BYTE0(reg_addr); /* starting address [07:00] */
    wr_buf[5] = LARK_CP_SPI_DUMMY;
    #endif

    for (i = 0; i < reg_width; i += 1) /* payload placed after WR head */
    {
        wr_buf[LARK_CP_SPI_WR_HEAD + i] = (reg_data >> (i * 8)) & 0xFF;
    }

    err = device->write(device->user_data, wr_buf, reg_width + LARK_CP_SPI_WR_HEAD);
    LARK_ERROR_RETURN(err);
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_i2c_mem_read(adi_lark_device_t *device, uint32_t addr, uint8_t *data, uint32_t byte_length)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t  err, max_payload_size;
    uint32_t i, data_offset, frame_payload_size;
    uint8_t  reg_width;
    LARK_NULL_POINTER_RETURN(device);

    err = adi_lark_cp_check_addr_length(addr, byte_length, &reg_width);
    LARK_ERROR_RETURN(err);

    max_payload_size = LARK_SDK_MAX_BUFSIZE - LARK_CP_I2C_RD_HEAD; /* max payload size, limited by buffer and read head */
    max_payload_size -= max_payload_size % reg_width;              /* if register is 32bit, must access by 4-multiple bytes */
    LARK_INVALID_PARAM_RETURN (max_payload_size < 1);

    for (data_offset = 0; data_offset < byte_length; data_offset += max_payload_size) /* generate frames */
    {
        frame_payload_size = (byte_length - data_offset < max_payload_size) ? byte_length - data_offset : max_payload_size;
        #ifdef LARK_LITE_SDK
        wr_buf[0] = LARK_CP_ADDR_BYTE1(data_offset + addr); /* starting address [15:08] */
        wr_buf[1] = LARK_CP_ADDR_BYTE0(data_offset + addr); /* starting address [07:00] */
        #endif
        #ifdef LARK_SDK
        wr_buf[0] = LARK_CP_ADDR_BYTE3(data_offset + addr); /* starting address [31:24] */
        wr_buf[1] = LARK_CP_ADDR_BYTE2(data_offset + addr); /* starting address [23:16] */
        wr_buf[2] = LARK_CP_ADDR_BYTE1(data_offset + addr); /* starting address [15:08] */
        wr_buf[3] = LARK_CP_ADDR_BYTE0(data_offset + addr); /* starting address [07:00] */
        #endif
        err = device->read(device->user_data, rd_buf, frame_payload_size, wr_buf, LARK_CP_I2C_RD_HEAD);
        LARK_ERROR_RETURN(err);

        for (i = 0; i < frame_payload_size; i += 1) /* returned payload from above are also offset by SPI_RD_HEAD */
        {
            data[data_offset + i] = rd_buf[i];
        }
    }
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_i2c_mem_write(adi_lark_device_t *device, uint32_t addr, uint8_t *data, uint32_t byte_length)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t  err, max_payload_size;
    uint32_t i, data_offset, frame_payload_size;
    uint8_t  reg_width;
    LARK_NULL_POINTER_RETURN(device);

    err = adi_lark_cp_check_addr_length(addr, byte_length, &reg_width);
    LARK_ERROR_RETURN(err);

    max_payload_size = LARK_SDK_MAX_BUFSIZE - LARK_CP_I2C_WR_HEAD; /* max payload size, limited by buffer and read head */
    max_payload_size -= max_payload_size % reg_width;              /* if register is 32bit, must access by 4-multiple bytes */
    LARK_INVALID_PARAM_RETURN (max_payload_size < 1);

    for (data_offset = 0; data_offset < byte_length; data_offset += max_payload_size) /* generate frames */
    {
        frame_payload_size = (byte_length - data_offset < max_payload_size) ? byte_length - data_offset : max_payload_size;
        #ifdef LARK_LITE_SDK
        wr_buf[0] = LARK_CP_ADDR_BYTE1(data_offset + addr); /* starting address [15:08] */
        wr_buf[1] = LARK_CP_ADDR_BYTE0(data_offset + addr); /* starting address [07:00] */
        #endif
        #ifdef LARK_SDK
        wr_buf[0] = LARK_CP_ADDR_BYTE3(data_offset + addr); /* starting address [31:24] */
        wr_buf[1] = LARK_CP_ADDR_BYTE2(data_offset + addr); /* starting address [23:16] */
        wr_buf[2] = LARK_CP_ADDR_BYTE1(data_offset + addr); /* starting address [15:08] */
        wr_buf[3] = LARK_CP_ADDR_BYTE0(data_offset + addr); /* starting address [07:00] */
        #endif
        for (i = 0; i < frame_payload_size; i += 1) /* payload placed after WR head */
        {
            wr_buf[LARK_CP_I2C_WR_HEAD + i] = data[data_offset + i];
        }

        err = device->write(device->user_data, wr_buf, frame_payload_size + LARK_CP_I2C_WR_HEAD);
        LARK_ERROR_RETURN(err);
    }
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_i2c_reg_read(adi_lark_device_t *device, uint32_t reg_addr, uint32_t *reg_data)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t err, max_payload_size;
    uint32_t i;
    uint8_t reg_width;
    LARK_NULL_POINTER_RETURN(device);

    err = adi_lark_cp_check_addr_length(reg_addr, 0, &reg_width);
    LARK_ERROR_RETURN(err);

    max_payload_size = LARK_SDK_MAX_BUFSIZE - LARK_CP_I2C_RD_HEAD; /* max payload size, limited by buffer and read head */
    max_payload_size -= max_payload_size % reg_width; /* if register is 32bit, must access by 4-multiple bytes */
    LARK_INVALID_PARAM_RETURN (max_payload_size < 1);

    #ifdef LARK_LITE_SDK
    wr_buf[0] = LARK_CP_ADDR_BYTE1(reg_addr); /* starting address [15:08] */
    wr_buf[1] = LARK_CP_ADDR_BYTE0(reg_addr); /* starting address [07:00] */
    #endif
    #ifdef LARK_SDK
    wr_buf[0] = LARK_CP_ADDR_BYTE3(reg_addr); /* starting address [31:24] */
    wr_buf[1] = LARK_CP_ADDR_BYTE2(reg_addr); /* starting address [23:16] */
    wr_buf[2] = LARK_CP_ADDR_BYTE1(reg_addr); /* starting address [15:08] */
    wr_buf[3] = LARK_CP_ADDR_BYTE0(reg_addr); /* starting address [07:00] */
    #endif

    err = device->read(device->user_data, rd_buf, reg_width, wr_buf, LARK_CP_I2C_RD_HEAD); /* chip address defined at device->user_data */
    LARK_ERROR_RETURN(err);

    *reg_data = 0;
    for (i = 0; i < reg_width; i += 1) /* returned payload from above are also offset by I2C_RD_HEAD */
    {
        *reg_data += rd_buf[i] << (i * 8);
    }
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_i2c_reg_write(adi_lark_device_t *device, uint32_t reg_addr, uint32_t reg_data)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t err, max_payload_size;
    uint32_t i;
    uint8_t reg_width;

    LARK_NULL_POINTER_RETURN(device);
    LARK_NULL_POINTER_RETURN(device->write);

    err = adi_lark_cp_check_addr_length(reg_addr, 0, &reg_width);
    LARK_ERROR_RETURN(err);

    max_payload_size = LARK_SDK_MAX_BUFSIZE - LARK_CP_I2C_WR_HEAD; /* max payload size, limited by buffer and read head */
    max_payload_size -= max_payload_size % reg_width; /* if register is 32bit, must access by 4-multiple bytes */
    LARK_INVALID_PARAM_RETURN (max_payload_size < 1);

    #ifdef LARK_LITE_SDK
    wr_buf[0] = LARK_CP_ADDR_BYTE1(reg_addr); /* starting address [15:08] */
    wr_buf[1] = LARK_CP_ADDR_BYTE0(reg_addr); /* starting address [07:00] */
    #endif
    #ifdef LARK_SDK
    wr_buf[0] = LARK_CP_ADDR_BYTE3(reg_addr); /* starting address [31:24] */
    wr_buf[1] = LARK_CP_ADDR_BYTE2(reg_addr); /* starting address [23:16] */
    wr_buf[2] = LARK_CP_ADDR_BYTE1(reg_addr); /* starting address [15:08] */
    wr_buf[3] = LARK_CP_ADDR_BYTE0(reg_addr); /* starting address [07:00] */
    #endif

    for (i = 0; i < reg_width; i += 1) /* payload placed after WR head */
    {
        wr_buf[LARK_CP_I2C_WR_HEAD + i] = (reg_data >> (i * 8)) & 0xFF;
    }

    err = device->write(device->user_data, wr_buf, reg_width + LARK_CP_I2C_WR_HEAD); /* chip address defined at device->user_data */
    LARK_ERROR_RETURN(err);
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_check_addr_length(uint32_t first_byte_addr, uint32_t length, uint8_t *reg_width)
{
    uint32_t last_byte_addr;
    uint8_t  width = 0;

    /* if length is set to 0, this function assumes no specifc length required (dont know or dont care). */
    /* Will only make sure first_byte_address to be compatible with block being operated. */
    last_byte_addr = first_byte_addr + ((length > 0) ? (length - 1) : 0);

    if (first_byte_addr >= LARK_8BIT_REG_ADDR_START && first_byte_addr <= LARK_8BIT_REG_ADDR_END)
    {
        if (last_byte_addr >= LARK_8BIT_REG_ADDR_START && last_byte_addr <= LARK_8BIT_REG_ADDR_END)
        {
            width = 1;
        }
    }
    else
    {
        if (last_byte_addr < LARK_8BIT_REG_ADDR_START || last_byte_addr > LARK_8BIT_REG_ADDR_END)
        {
            width = 4;
        }
    }

    if (width > 0 && first_byte_addr % width == 0 && length % width == 0)
    {
        *reg_width = width;
        return API_LARK_ERROR_OK;
    }

    return API_LARK_ERROR_INVALID_PARAM;
}

int32_t adi_lark_cp_uart_mem_read(adi_lark_device_t *device, uint32_t addr, uint8_t *data, uint32_t byte_length)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t  err;
    uint8_t  reg_width;
    adi_lark_cp_uart_reg_t uart_reg;

    LARK_NULL_POINTER_RETURN(device);
    LARK_NULL_POINTER_RETURN(device->read);

    err = adi_lark_cp_check_addr_length(addr, byte_length, &reg_width);
    LARK_ERROR_RETURN(err);

    uart_reg.index = 0;
    uart_reg.crc_out = 0;
    uart_reg.reg_addr = addr;
    uart_reg.fill_type = LARK_CP_UART_FILL_TYPE_1_BYTE;
    err = adi_lark_cp_uart_fill_buffer(&uart_reg, wr_buf, byte_length, LARK_CP_UART_CMD_RD);
    LARK_ERROR_RETURN(err);
    err = device->write(device->user_data, wr_buf, uart_reg.index);
    LARK_ERROR_RETURN(err);
    err = adi_lark_cp_uart_parse_read_data(device, LARK_CP_UART_ID, data, byte_length, LARK_CP_UART_READ_TYPE_MEM);
    LARK_ERROR_RETURN(err);
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_uart_mem_write(adi_lark_device_t *device, uint32_t addr, uint8_t *data, uint32_t byte_length)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t  err, max_payload_size;
    uint32_t data_offset, frame_payload_size;
    uint8_t  reg_width, write_stat;
    adi_lark_cp_uart_reg_t uart_reg;
    
    LARK_NULL_POINTER_RETURN(device);
    LARK_NULL_POINTER_RETURN(device->write);
    
    err = adi_lark_cp_check_addr_length(addr, byte_length, &reg_width);
    LARK_ERROR_RETURN(err);

    max_payload_size = LARK_SDK_MAX_BUFSIZE/2;
    max_payload_size -= LARK_CP_UART_HEAD_MIN_OVERHEAD;
    max_payload_size -= max_payload_size % reg_width;
    LARK_INVALID_PARAM_RETURN (max_payload_size < 1 || byte_length == 0);

    for (data_offset = 0; data_offset < byte_length; data_offset += max_payload_size) /* generate frames */
    {
        frame_payload_size = (byte_length - data_offset < max_payload_size) ? byte_length - data_offset : max_payload_size;
        uart_reg.index   = 0;
        uart_reg.crc_out = 0;
        uart_reg.reg_addr = addr + data_offset;
        uart_reg.reg_data = data + data_offset;
        uart_reg.fill_type = LARK_CP_UART_FILL_TYPE_1_BYTE;
        err = adi_lark_cp_uart_fill_buffer(&uart_reg, wr_buf, frame_payload_size, LARK_CP_UART_CMD_WR);
        LARK_ERROR_RETURN(err);
        err = device->write(device->user_data, wr_buf, uart_reg.index);
        LARK_ERROR_RETURN(err);

        err = adi_lark_cp_uart_check_write_stat(device, LARK_CP_UART_ID, &write_stat);
        LARK_ERROR_RETURN(err);
        if(write_stat != API_LARK_ERROR_OK)
            return API_LARK_ERROR_CP_UART_STAT;
    }
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_uart_reg_read(adi_lark_device_t *device, uint32_t reg_addr, uint32_t *reg_data)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t  err;
    uint32_t data_len;
    adi_lark_cp_uart_reg_t uart_reg;

    LARK_NULL_POINTER_RETURN(device);
    LARK_NULL_POINTER_RETURN(device->read);
    LARK_NULL_POINTER_RETURN(device->write);
    LARK_NULL_POINTER_RETURN(reg_data);

    uart_reg.index = 0;
    uart_reg.crc_out = 0;
    uart_reg.reg_addr = reg_addr;
    uart_reg.fill_type = LARK_CP_UART_FILL_TYPE_1_BYTE;
    data_len = (reg_addr >= LARK_8BIT_REG_ADDR_START && reg_addr <= LARK_8BIT_REG_ADDR_END) ? 1 : 4;
    err = adi_lark_cp_uart_fill_buffer(&uart_reg, wr_buf, data_len, LARK_CP_UART_CMD_RD);
    LARK_ERROR_RETURN(err);
    err = device->write(device->user_data, wr_buf, uart_reg.index);
    LARK_ERROR_RETURN(err);
    err = adi_lark_cp_uart_parse_read_data(device, LARK_CP_UART_ID, (uint8_t*)reg_data, data_len, LARK_CP_UART_READ_TYPE_REG);
    LARK_ERROR_RETURN(err);
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_uart_reg_write(adi_lark_device_t *device, uint32_t reg_addr, uint32_t reg_data)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t  err;
    uint8_t  write_stat, data_len;
    uint32_t data;
    adi_lark_cp_uart_reg_t uart_reg;

    LARK_NULL_POINTER_RETURN(device);
    LARK_NULL_POINTER_RETURN(device->write);
    data = reg_data;
    uart_reg.index   = 0;
    uart_reg.crc_out = 0;
    uart_reg.reg_addr = reg_addr;
    uart_reg.reg_data = (uint8_t*)&data;
    uart_reg.fill_type = LARK_CP_UART_FILL_TYPE_4_BYTE;
    data_len = (reg_addr >= LARK_8BIT_REG_ADDR_START && reg_addr <= LARK_8BIT_REG_ADDR_END) ? 1 : 4;
    err = adi_lark_cp_uart_fill_buffer(&uart_reg, wr_buf, data_len, LARK_CP_UART_CMD_WR);
    LARK_ERROR_RETURN(err);
    err = device->write(device->user_data, wr_buf, uart_reg.index);
    LARK_ERROR_RETURN(err);

    err = adi_lark_cp_uart_check_write_stat(device, LARK_CP_UART_ID, &write_stat);
    LARK_ERROR_RETURN(err);
    if(write_stat != API_LARK_ERROR_OK)
        return API_LARK_ERROR_CP_UART_STAT;
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_uart_update_crc8(uint8_t crc_in, uint8_t data_byte, uint8_t *crc_out)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    if(crc_out == NULL)
        return API_LARK_ERROR_NULL_PARAM;
    *crc_out = crc8_table[crc_in ^ data_byte];
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_uart_fill_buffer(adi_lark_cp_uart_reg_t *uart_reg, uint8_t *buf, uint32_t data_len, uint8_t rw_type)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t  err;
    uint8_t  crc = 0, fill_type = uart_reg->fill_type;
    uint32_t addr_swapped;

    if(uart_reg == NULL || buf == NULL)
    {
        return API_LARK_ERROR_NULL_PARAM;
    }

    buf[0] = LARK_CP_UART_FRAME_HEAD;
    buf[1] = 0;                                                             /* for register read/write, only one frame, ID = 0 */
    err = adi_lark_cp_uart_update_crc8(LARK_CP_UART_CRC_INIT, buf[1], &crc);
    LARK_ERROR_RETURN(err);

    buf[2] = rw_type;
    err = adi_lark_cp_uart_update_crc8(crc, buf[2], &crc);
    LARK_ERROR_RETURN(err);

    uart_reg->index = 3;
    uart_reg->crc_out = crc;
    uart_reg->fill_type = LARK_CP_UART_FILL_TYPE_4_BYTE;
    #ifdef LARK_LITE_SDK
    addr_swapped = (LARK_CP_ADDR_BYTE0(uart_reg->reg_addr) << 8)  + (LARK_CP_ADDR_BYTE1(uart_reg->reg_addr));
    err = adi_lark_cp_uart_fill_data(uart_reg, buf, 2, (uint8_t*)&addr_swapped);
    LARK_ERROR_RETURN(err);
    #endif
    #ifdef LARK_SDK
    addr_swapped = (LARK_CP_ADDR_BYTE0(uart_reg->reg_addr) << 24) + (LARK_CP_ADDR_BYTE1(uart_reg->reg_addr) << 16) +
                   (LARK_CP_ADDR_BYTE2(uart_reg->reg_addr) << 8)  + (LARK_CP_ADDR_BYTE3(uart_reg->reg_addr));
    err = adi_lark_cp_uart_fill_data(uart_reg, buf, 4, (uint8_t*)&addr_swapped);
    LARK_ERROR_RETURN(err);
    #endif

    crc = uart_reg->crc_out;

    if (((data_len >> 8) & 0xFF) == LARK_CP_UART_FRAME_HEAD || ((data_len >> 8) & 0xFF) == LARK_CP_UART_FRAME_TAIL||((data_len >> 8) & 0xFF) == LARK_CP_UART_ESCAPE)
    {
        buf[uart_reg->index++] = LARK_CP_UART_ESCAPE;                        /* LENH */
        err = adi_lark_cp_uart_update_crc8(crc, LARK_CP_UART_ESCAPE, &crc);
        LARK_ERROR_RETURN(err);
        buf[uart_reg->index++] = ((data_len >> 8) & 0xFF)^LARK_CP_UART_ESCAPE_MASK;
        err = adi_lark_cp_uart_update_crc8(crc, ((data_len >> 8) & 0xFF) ^ LARK_CP_UART_ESCAPE_MASK, &crc);
        LARK_ERROR_RETURN(err);
    }
    else
    {
        buf[uart_reg->index++] = (data_len >> 8) & 0xFF;                        /* LENH */
        err = adi_lark_cp_uart_update_crc8(crc, (data_len >> 8) & 0xFF, &crc);
        LARK_ERROR_RETURN(err);
    }

    if ((data_len & 0xFF)== LARK_CP_UART_FRAME_HEAD || (data_len & 0xFF)== LARK_CP_UART_FRAME_TAIL || (data_len & 0xFF)== LARK_CP_UART_ESCAPE )
    {
        buf[uart_reg->index++] = LARK_CP_UART_ESCAPE;                        /* LENL*/
        err = adi_lark_cp_uart_update_crc8(crc, LARK_CP_UART_ESCAPE, &crc);
        LARK_ERROR_RETURN(err);
        buf[uart_reg->index++] = (data_len & 0xFF)^LARK_CP_UART_ESCAPE_MASK;
        err = adi_lark_cp_uart_update_crc8(crc, (data_len & 0xFF) ^ LARK_CP_UART_ESCAPE_MASK, &crc);
        LARK_ERROR_RETURN(err);
    }
    else
    {
        buf[uart_reg->index++] = data_len & 0xFF;                               /* LENL */
        err = adi_lark_cp_uart_update_crc8(crc, data_len, &crc);
        LARK_ERROR_RETURN(err);
    }

    uart_reg->crc_out = crc;                                                /* save the crc, will be used in the folowing function call */
    if(rw_type == LARK_CP_UART_CMD_WR)
    {
        uart_reg->fill_type = fill_type;
        err = adi_lark_cp_uart_fill_data(uart_reg, buf, data_len, uart_reg->reg_data); /* fill data */
        LARK_ERROR_RETURN(err);
    }
    if(uart_reg->crc_out == LARK_CP_UART_FRAME_HEAD || uart_reg->crc_out ==  LARK_CP_UART_FRAME_TAIL || uart_reg->crc_out ==  LARK_CP_UART_ESCAPE)
    {
        buf[uart_reg->index++] = LARK_CP_UART_ESCAPE;
        buf[uart_reg->index++] = uart_reg->crc_out ^ LARK_CP_UART_ESCAPE_MASK;
    }
    else
        buf[uart_reg->index++] = uart_reg->crc_out;
    buf[uart_reg->index++] = LARK_CP_UART_FRAME_TAIL;
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_uart_fill_data(adi_lark_cp_uart_reg_t *uart_reg, uint8_t *buf, uint32_t data_len, uint8_t *data)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t err;
    uint8_t crc, data_byte, i;
    uint8_t fill_type  = uart_reg->fill_type;

    if(uart_reg == NULL || buf == NULL)
    {
        return API_LARK_ERROR_NULL_PARAM;
    }

    crc = uart_reg->crc_out;
    for(i = 0; i < data_len; i++)
    {
        if(fill_type == LARK_CP_UART_FILL_TYPE_4_BYTE)
            data_byte = *(uint32_t*)data >> (i * 8) & 0xFF;
        else
            data_byte = *(data + i);
        if(data_byte == LARK_CP_UART_FRAME_HEAD || data_byte ==  LARK_CP_UART_FRAME_TAIL || data_byte ==  LARK_CP_UART_ESCAPE)
        {
            buf[uart_reg->index++] = LARK_CP_UART_ESCAPE;
            err = adi_lark_cp_uart_update_crc8(crc, LARK_CP_UART_ESCAPE, &crc);
            LARK_ERROR_RETURN(err);
            buf[uart_reg->index++] = data_byte ^ LARK_CP_UART_ESCAPE_MASK;
            err = adi_lark_cp_uart_update_crc8(crc, data_byte ^ LARK_CP_UART_ESCAPE_MASK, &crc);
        }
        else
        {
            buf[uart_reg->index++] = data_byte;
            err = adi_lark_cp_uart_update_crc8(crc, data_byte, &crc);
        }
        LARK_ERROR_RETURN(err);
    }
    uart_reg->crc_out = crc;
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_uart_check_write_stat(adi_lark_device_t *device, uint8_t write_id, uint8_t *stat)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t err;
    uint8_t crc = LARK_CP_UART_CRC_INIT, data_byte;
    bool is_escaping = false;
    adi_lark_cp_uart_write_stat_state_e state = LARK_CP_UART_WRITE_STAT_STATE_HEAD;

    LARK_NULL_POINTER_RETURN(device);
    LARK_NULL_POINTER_RETURN(device->read);
    LARK_NULL_POINTER_RETURN(stat);

    while(state != LARK_CP_UART_WRITE_STAT_STATE_FINISHED)
    {
        err = device->read(device->user_data, &data_byte, 1, NULL, 0);
        LARK_ERROR_RETURN(err);
        switch(state)
        {
            case LARK_CP_UART_WRITE_STAT_STATE_HEAD:
                if(data_byte != LARK_CP_UART_FRAME_HEAD)
                    return API_LARK_ERROR_CP_UART_HEAD;
                state++;
                break;
            case LARK_CP_UART_WRITE_STAT_STATE_ID:
            case LARK_CP_UART_WRITE_STAT_STATE_STAT:
                if(data_byte == LARK_CP_UART_ESCAPE)
                {
                    err = adi_lark_cp_uart_update_crc8(crc, data_byte, &crc);
                    LARK_ERROR_RETURN(err);
                    is_escaping = true;
                }
                else
                {
                    err = adi_lark_cp_uart_update_crc8(crc, data_byte, &crc);
                    LARK_ERROR_RETURN(err);
                    if(is_escaping)
                    {
                        data_byte ^= LARK_CP_UART_ESCAPE_MASK;
                        is_escaping = false;
                    }
                }
                if(!is_escaping)
                {
                    if(state == LARK_CP_UART_WRITE_STAT_STATE_ID)
                    {
                        if(data_byte != write_id)
                            return API_LARK_ERROR_CP_UART_ID;
                    }
                    else /*LARK_CP_UART_WRITE_STAT_STATE_STAT*/
                        *stat = data_byte;
                    state++;
                }
                break;
            case LARK_CP_UART_WRITE_STAT_STATE_CRC:
                if(data_byte == LARK_CP_UART_ESCAPE)
                {
                    is_escaping = true;
                }
                else
                {
                    if(is_escaping)
                    {
                        data_byte ^= LARK_CP_UART_ESCAPE_MASK;
                        is_escaping = false;
                    }
                }
                if(!is_escaping)
                {
                    if(crc != data_byte)
                        return API_LARK_ERROR_CP_UART_CRC;
                    state++;
                }
                break;
            case LARK_CP_UART_WRITE_STAT_STATE_TAIL:
                if(data_byte != LARK_CP_UART_FRAME_TAIL)
                    return API_LARK_ERROR_CP_UART_TAIL;
                state++;
                break;
            default:
                return API_LARK_ERROR_CP_UART_WRITE_STATE;
        }
    }
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_uart_parse_read_data(adi_lark_device_t *device, uint8_t read_id, uint8_t *reg_data, uint32_t data_len, uint32_t read_type)
{
    #if (LARK_SDK_RUN_ON_HIFI3Z == 0)
    int32_t err;
    uint8_t crc = LARK_CP_UART_CRC_INIT, data_byte;
    uint32_t byte_count = 0;
    adi_lark_cp_uart_read_data_state_e state = LARK_CP_UART_READ_DATA_STATE_HEAD;
    bool is_escaping = false;

    LARK_NULL_POINTER_RETURN(device);
    LARK_NULL_POINTER_RETURN(reg_data);

    if(read_type == LARK_CP_UART_READ_TYPE_REG)
        *(uint32_t*)reg_data = 0;
    while(state != LARK_CP_UART_READ_DATA_STATE_FINISHED)
    {
        err = device->read(device->user_data, &data_byte, 1, NULL, 0);
        LARK_ERROR_RETURN(err);
        switch(state)
        {
            case LARK_CP_UART_READ_DATA_STATE_HEAD:
                if(data_byte != LARK_CP_UART_FRAME_HEAD)
                    return API_LARK_ERROR_CP_UART_HEAD;
                state++;
                break;
            case LARK_CP_UART_READ_DATA_STATE_ID:
            case LARK_CP_UART_READ_DATA_STATE_STAT:
                if(data_byte == LARK_CP_UART_ESCAPE)
                {
                    err = adi_lark_cp_uart_update_crc8(crc, data_byte, &crc);
                    LARK_ERROR_RETURN(err);
                    is_escaping = true;
                }
                else
                {
                    err = adi_lark_cp_uart_update_crc8(crc, data_byte, &crc);
                    LARK_ERROR_RETURN(err);
                    if(is_escaping)
                    {
                        data_byte ^= LARK_CP_UART_ESCAPE_MASK;
                        is_escaping = false;
                    }
                }
                if(!is_escaping)
                {
                    if(state == LARK_CP_UART_READ_DATA_STATE_ID)
                    {
                        if(data_byte != read_id)
                            return API_LARK_ERROR_CP_UART_ID;
                    }
                    else /*LARK_CP_UART_READ_DATA_STATE_STAT*/
                    {
                        if(data_byte != 0)
                            return API_LARK_ERROR_CP_UART_STAT;
                    }
                    state++;
                }
                break;
            case LARK_CP_UART_READ_DATA_STATE_DATA:
                if(data_byte == LARK_CP_UART_ESCAPE)
                {
                    err = adi_lark_cp_uart_update_crc8(crc, data_byte, &crc);
                    LARK_ERROR_RETURN(err);
                    is_escaping = true;
                }
                else
                {
                    err = adi_lark_cp_uart_update_crc8(crc, data_byte, &crc);
                    LARK_ERROR_RETURN(err);
                    if(is_escaping)
                    {
                        data_byte ^= LARK_CP_UART_ESCAPE_MASK;
                        is_escaping = false;
                    }
                    if(read_type == LARK_CP_UART_READ_TYPE_REG)
                        *(uint32_t*)reg_data += data_byte << byte_count * 8;
                    else
                        *(reg_data + byte_count) = data_byte;
                    byte_count++;
                }
                if(byte_count == data_len)
                {
                    state++;
                }
                break;
            case LARK_CP_UART_READ_DATA_STATE_CRC:
                if(data_byte == LARK_CP_UART_ESCAPE)
                {
                    is_escaping = true;
                }
                else
                {
                    if(is_escaping)
                    {
                        data_byte ^= LARK_CP_UART_ESCAPE_MASK;
                        is_escaping = false;
                    }
                }
                if(!is_escaping)
                {
                    if(crc != data_byte)
                        return API_LARK_ERROR_CP_UART_CRC;
                    state++;
                }
                break;
            case LARK_CP_UART_READ_DATA_STATE_TAIL:
                if(data_byte != LARK_CP_UART_FRAME_TAIL)
                    return API_LARK_ERROR_CP_UART_TAIL;
                state++;
                break;
            default:
                return API_LARK_ERROR_CP_UART_WRITE_STATE;
        }
    }
    #endif

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_native_reg_read(adi_lark_device_t *device, uint32_t reg_addr, uint32_t *reg_data)
{
    LARK_NULL_POINTER_RETURN(device);
    if(reg_addr >= LARK_8BIT_REG_ADDR_START && reg_addr <= LARK_8BIT_REG_ADDR_END)
        *reg_data =  (uint32_t)(*(volatile uint8_t *)reg_addr);
    else
        *reg_data = *(volatile uint32_t *)reg_addr;
    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_native_reg_write(adi_lark_device_t *device, uint32_t reg_addr, uint32_t reg_data)
{
    LARK_NULL_POINTER_RETURN(device);
    if(reg_addr >= LARK_8BIT_REG_ADDR_START && reg_addr <= LARK_8BIT_REG_ADDR_END)
        *(volatile uint8_t  *)reg_addr = (uint8_t)reg_data;
    else
        *(volatile uint32_t *)reg_addr = reg_data;
    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_native_mem_read(adi_lark_device_t *device, uint32_t addr, uint8_t *data, uint32_t byte_length)
{
    uint32_t i, word_length;
    LARK_NULL_POINTER_RETURN(device);
    if(addr >= LARK_8BIT_REG_ADDR_START && addr <= LARK_8BIT_REG_ADDR_END)
    {
        for (i = 0; i < byte_length; i ++)
            data[i] = *(volatile uint8_t *)(addr + i);
    }
    else
    {
        word_length = byte_length >> 2;
        for (i = 0; i < word_length; i ++)
            *((uint32_t *)data + i) = *(volatile uint32_t *)(addr + 4*i);
    }

    return API_LARK_ERROR_OK;
}

int32_t adi_lark_cp_native_mem_write(adi_lark_device_t *device, uint32_t addr, uint8_t *data, uint32_t byte_length)
{
    uint32_t i, word_length;
    LARK_NULL_POINTER_RETURN(device);
    if(addr >= LARK_8BIT_REG_ADDR_START && addr <= LARK_8BIT_REG_ADDR_END)
    {
        for (i = 0; i < byte_length; i ++)
            *(volatile uint8_t *)(addr + i) = data[i];
    }
    else
    {
        word_length = byte_length >> 2;
        for (i = 0; i < word_length; i ++)
            *(volatile uint32_t *)(addr + 4*i) = *((uint32_t *)data + i);
    }

    return API_LARK_ERROR_OK;
}

/*! @} */
